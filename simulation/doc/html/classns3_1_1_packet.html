<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>My Project: ns3::Packet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   &#160;<span id="projectnumber">beta 0.01</span>
   </div>
   <div id="projectbrief">Doxygen for HPCC-plus</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classns3_1_1_packet.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classns3_1_1_packet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ns3::Packet Class Reference<div class="ingroups"><a class="el" href="group__packet.html">Packet</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>network packets  
 <a href="classns3_1_1_packet.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="packet_8h_source.html">packet.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ns3::Packet:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classns3_1_1_packet.png" usemap="#ns3::Packet_map" alt=""/>
  <map id="ns3::Packet_map" name="ns3::Packet_map">
<area href="classns3_1_1_simple_ref_count.html" alt="ns3::SimpleRefCount&lt; Packet &gt;" shape="rect" coords="0,56,189,80"/>
<area href="classns3_1_1empty.html" title="make Callback use a separate empty type " alt="ns3::empty" shape="rect" coords="0,0,189,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac1a30f8cf28346960cfac4a2c9fa7026"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#ac1a30f8cf28346960cfac4a2c9fa7026">Packet</a> ()</td></tr>
<tr class="memdesc:ac1a30f8cf28346960cfac4a2c9fa7026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty packet with a new uid (as returned by getUid).  <a href="#ac1a30f8cf28346960cfac4a2c9fa7026">More...</a><br/></td></tr>
<tr class="separator:ac1a30f8cf28346960cfac4a2c9fa7026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b64449ccabad33e9e61c70e06db166"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#aa8b64449ccabad33e9e61c70e06db166">Packet</a> (const <a class="el" href="classns3_1_1_packet.html">Packet</a> &amp;o)</td></tr>
<tr class="separator:aa8b64449ccabad33e9e61c70e06db166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7627bc5113f3fa52ad68a20d57aa94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classns3_1_1_packet.html">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a8f7627bc5113f3fa52ad68a20d57aa94">operator=</a> (const <a class="el" href="classns3_1_1_packet.html">Packet</a> &amp;o)</td></tr>
<tr class="separator:a8f7627bc5113f3fa52ad68a20d57aa94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897aab15901dcf1f05f075db7b8d04b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a897aab15901dcf1f05f075db7b8d04b1">Packet</a> (uint32_t size)</td></tr>
<tr class="memdesc:a897aab15901dcf1f05f075db7b8d04b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a packet with a zero-filled payload.  <a href="#a897aab15901dcf1f05f075db7b8d04b1">More...</a><br/></td></tr>
<tr class="separator:a897aab15901dcf1f05f075db7b8d04b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d46939241156115411e66aa1a65f09"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#ab2d46939241156115411e66aa1a65f09">Packet</a> (uint8_t const *buffer, uint32_t size, bool magic)</td></tr>
<tr class="memdesc:ab2d46939241156115411e66aa1a65f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new packet from the serialized buffer.  <a href="#ab2d46939241156115411e66aa1a65f09">More...</a><br/></td></tr>
<tr class="separator:ab2d46939241156115411e66aa1a65f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6a0314efee85ac6cf4a64e05450538"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a7f6a0314efee85ac6cf4a64e05450538">Packet</a> (uint8_t const *buffer, uint32_t size)</td></tr>
<tr class="memdesc:a7f6a0314efee85ac6cf4a64e05450538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a packet with payload filled with the content of this buffer.  <a href="#a7f6a0314efee85ac6cf4a64e05450538">More...</a><br/></td></tr>
<tr class="separator:a7f6a0314efee85ac6cf4a64e05450538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f6113606b355b2b346e2245fa2a3d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_packet.html">Packet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a16f6113606b355b2b346e2245fa2a3d0">CreateFragment</a> (uint32_t start, uint32_t length) const </td></tr>
<tr class="memdesc:a16f6113606b355b2b346e2245fa2a3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new packet which contains a fragment of the original packet.  <a href="#a16f6113606b355b2b346e2245fa2a3d0">More...</a><br/></td></tr>
<tr class="separator:a16f6113606b355b2b346e2245fa2a3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462855c9929954d4301a4edfe55f4f1c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a462855c9929954d4301a4edfe55f4f1c">GetSize</a> (void) const </td></tr>
<tr class="separator:a462855c9929954d4301a4edfe55f4f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465108c595a0bc592095cbcab1832ed8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a465108c595a0bc592095cbcab1832ed8">AddHeader</a> (const <a class="el" href="classns3_1_1_header.html">Header</a> &amp;header)</td></tr>
<tr class="memdesc:a465108c595a0bc592095cbcab1832ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add header to this packet.  <a href="#a465108c595a0bc592095cbcab1832ed8">More...</a><br/></td></tr>
<tr class="separator:a465108c595a0bc592095cbcab1832ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0961eccf975d75f902d40956c93ba63e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a0961eccf975d75f902d40956c93ba63e">RemoveHeader</a> (<a class="el" href="classns3_1_1_header.html">Header</a> &amp;header)</td></tr>
<tr class="memdesc:a0961eccf975d75f902d40956c93ba63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize and remove the header from the internal buffer.  <a href="#a0961eccf975d75f902d40956c93ba63e">More...</a><br/></td></tr>
<tr class="separator:a0961eccf975d75f902d40956c93ba63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc63487bea70945c418f4c3e9b81964"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#aadc63487bea70945c418f4c3e9b81964">PeekHeader</a> (<a class="el" href="classns3_1_1_header.html">Header</a> &amp;header) const </td></tr>
<tr class="memdesc:aadc63487bea70945c418f4c3e9b81964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize but does <em>not</em> remove the header from the internal buffer.  <a href="#aadc63487bea70945c418f4c3e9b81964">More...</a><br/></td></tr>
<tr class="separator:aadc63487bea70945c418f4c3e9b81964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26b490c30ae5bc98be5181ec6e06db8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#ae26b490c30ae5bc98be5181ec6e06db8">AddTrailer</a> (const <a class="el" href="classns3_1_1_trailer.html">Trailer</a> &amp;trailer)</td></tr>
<tr class="memdesc:ae26b490c30ae5bc98be5181ec6e06db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add trailer to this packet.  <a href="#ae26b490c30ae5bc98be5181ec6e06db8">More...</a><br/></td></tr>
<tr class="separator:ae26b490c30ae5bc98be5181ec6e06db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2155e042083e9a17ad3b33f9fecb4be4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a2155e042083e9a17ad3b33f9fecb4be4">RemoveTrailer</a> (<a class="el" href="classns3_1_1_trailer.html">Trailer</a> &amp;trailer)</td></tr>
<tr class="memdesc:a2155e042083e9a17ad3b33f9fecb4be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a deserialized trailer from the internal buffer.  <a href="#a2155e042083e9a17ad3b33f9fecb4be4">More...</a><br/></td></tr>
<tr class="separator:a2155e042083e9a17ad3b33f9fecb4be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1fc287b3fc4fc12e72954e35342131"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#ace1fc287b3fc4fc12e72954e35342131">PeekTrailer</a> (<a class="el" href="classns3_1_1_trailer.html">Trailer</a> &amp;trailer)</td></tr>
<tr class="memdesc:ace1fc287b3fc4fc12e72954e35342131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize but does <em>not</em> remove a trailer from the internal buffer.  <a href="#ace1fc287b3fc4fc12e72954e35342131">More...</a><br/></td></tr>
<tr class="separator:ace1fc287b3fc4fc12e72954e35342131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ec3d4250b425468764de58f5837b6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a14ec3d4250b425468764de58f5837b6b">AddAtEnd</a> (<a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; const <a class="el" href="classns3_1_1_packet.html">Packet</a> &gt; packet)</td></tr>
<tr class="memdesc:a14ec3d4250b425468764de58f5837b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate the input packet at the end of the current packet.  <a href="#a14ec3d4250b425468764de58f5837b6b">More...</a><br/></td></tr>
<tr class="separator:a14ec3d4250b425468764de58f5837b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae964f1fcfd496c6c0db1b73f27e78530"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#ae964f1fcfd496c6c0db1b73f27e78530">AddPaddingAtEnd</a> (uint32_t size)</td></tr>
<tr class="separator:ae964f1fcfd496c6c0db1b73f27e78530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607de6c1abda2a960e99a3b59fd35d14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a607de6c1abda2a960e99a3b59fd35d14">RemoveAtEnd</a> (uint32_t size)</td></tr>
<tr class="memdesc:a607de6c1abda2a960e99a3b59fd35d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove size bytes from the end of the current packet It is safe to remove more bytes that what is present in the packet.  <a href="#a607de6c1abda2a960e99a3b59fd35d14">More...</a><br/></td></tr>
<tr class="separator:a607de6c1abda2a960e99a3b59fd35d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78aa207e7921dd2f9f7e0d0b7a1c730a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a78aa207e7921dd2f9f7e0d0b7a1c730a">RemoveAtStart</a> (uint32_t size)</td></tr>
<tr class="memdesc:a78aa207e7921dd2f9f7e0d0b7a1c730a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove size bytes from the start of the current packet.  <a href="#a78aa207e7921dd2f9f7e0d0b7a1c730a">More...</a><br/></td></tr>
<tr class="separator:a78aa207e7921dd2f9f7e0d0b7a1c730a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed76e440db303a3f2487a4c6f805adf"><td class="memItemLeft" align="right" valign="top">uint8_t const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#aaed76e440db303a3f2487a4c6f805adf">PeekData</a> (void) const <a class="el" href="deprecated_8h.html#a771fbc06c05c32655c757f56492d98c5">NS_DEPRECATED</a></td></tr>
<tr class="memdesc:aaed76e440db303a3f2487a4c6f805adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you try to change the content of the buffer returned by this method, you will die.  <a href="#aaed76e440db303a3f2487a4c6f805adf">More...</a><br/></td></tr>
<tr class="separator:aaed76e440db303a3f2487a4c6f805adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6d304b9e0d90733919ffe224b98f0d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a5a6d304b9e0d90733919ffe224b98f0d">CopyData</a> (uint8_t *buffer, uint32_t size) const </td></tr>
<tr class="separator:a5a6d304b9e0d90733919ffe224b98f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f6ad90367d0f86db3a5f39589c6897"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a62f6ad90367d0f86db3a5f39589c6897">CopyData</a> (std::ostream *os, uint32_t size) const </td></tr>
<tr class="separator:a62f6ad90367d0f86db3a5f39589c6897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5c70802a5f77fc5f0001e0cfc1898b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_packet.html">Packet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a5d5c70802a5f77fc5f0001e0cfc1898b">Copy</a> (void) const </td></tr>
<tr class="separator:a5d5c70802a5f77fc5f0001e0cfc1898b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f212c825b50e54d94f5b9ae99592e6a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a1f212c825b50e54d94f5b9ae99592e6a">GetUid</a> (void) const </td></tr>
<tr class="memdesc:a1f212c825b50e54d94f5b9ae99592e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_a.html">A</a> packet is allocated a new uid when it is created empty or with zero-filled payload.  <a href="#a1f212c825b50e54d94f5b9ae99592e6a">More...</a><br/></td></tr>
<tr class="separator:a1f212c825b50e54d94f5b9ae99592e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34058a5cdbf94673531f8c4001ab227"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#aa34058a5cdbf94673531f8c4001ab227">Print</a> (std::ostream &amp;os) const </td></tr>
<tr class="separator:aa34058a5cdbf94673531f8c4001ab227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0951ffaa12e116b03c4888085280501d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classns3_1_1_packet_metadata_1_1_item_iterator.html">PacketMetadata::ItemIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a0951ffaa12e116b03c4888085280501d">BeginItem</a> (void) const </td></tr>
<tr class="separator:a0951ffaa12e116b03c4888085280501d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7416c3bc8c1a9a86c8ade4dfd1d67d2d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a7416c3bc8c1a9a86c8ade4dfd1d67d2d">GetSerializedSize</a> (void) const </td></tr>
<tr class="memdesc:a7416c3bc8c1a9a86c8ade4dfd1d67d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For packet serializtion, the total size is checked in order to determine the size of the buffer required for serialization.  <a href="#a7416c3bc8c1a9a86c8ade4dfd1d67d2d">More...</a><br/></td></tr>
<tr class="separator:a7416c3bc8c1a9a86c8ade4dfd1d67d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939e41b065c6f9f77d3f51373baeaf7e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a939e41b065c6f9f77d3f51373baeaf7e">Serialize</a> (uint8_t *buffer, uint32_t maxSize) const </td></tr>
<tr class="separator:a939e41b065c6f9f77d3f51373baeaf7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5997caea8c22757acade2fcb4d7daca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#ad5997caea8c22757acade2fcb4d7daca">AddByteTag</a> (const <a class="el" href="classns3_1_1_tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="separator:ad5997caea8c22757acade2fcb4d7daca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c03f35c267e8534c29bdaa4686e4823"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classns3_1_1_byte_tag_iterator.html">ByteTagIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a3c03f35c267e8534c29bdaa4686e4823">GetByteTagIterator</a> (void) const </td></tr>
<tr class="separator:a3c03f35c267e8534c29bdaa4686e4823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1403c2411495827012fe000823c16a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a2e1403c2411495827012fe000823c16a">FindFirstMatchingByteTag</a> (<a class="el" href="classns3_1_1_tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="separator:a2e1403c2411495827012fe000823c16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083f54c9db31aeff30551a9e20fcda42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a083f54c9db31aeff30551a9e20fcda42">RemoveAllByteTags</a> (void)</td></tr>
<tr class="memdesc:a083f54c9db31aeff30551a9e20fcda42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all the tags stored in this packet.  <a href="#a083f54c9db31aeff30551a9e20fcda42">More...</a><br/></td></tr>
<tr class="separator:a083f54c9db31aeff30551a9e20fcda42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3766d81feb51b754cb036526c2f4366"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#af3766d81feb51b754cb036526c2f4366">PrintByteTags</a> (std::ostream &amp;os) const </td></tr>
<tr class="separator:af3766d81feb51b754cb036526c2f4366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7400b8655852f5271c5957250d0141af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a7400b8655852f5271c5957250d0141af">AddPacketTag</a> (const <a class="el" href="classns3_1_1_tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="separator:a7400b8655852f5271c5957250d0141af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078fe922d976a417ab25ba2f3c2fd667"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a078fe922d976a417ab25ba2f3c2fd667">RemovePacketTag</a> (<a class="el" href="classns3_1_1_tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="separator:a078fe922d976a417ab25ba2f3c2fd667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1734de11f2ca1e78a7872461a0625168"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a1734de11f2ca1e78a7872461a0625168">PeekPacketTag</a> (<a class="el" href="classns3_1_1_tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="separator:a1734de11f2ca1e78a7872461a0625168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7bc5d1067c1d7fbd0fd70289182e8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a6c7bc5d1067c1d7fbd0fd70289182e8b">RemoveAllPacketTags</a> (void)</td></tr>
<tr class="memdesc:a6c7bc5d1067c1d7fbd0fd70289182e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all packet tags.  <a href="#a6c7bc5d1067c1d7fbd0fd70289182e8b">More...</a><br/></td></tr>
<tr class="separator:a6c7bc5d1067c1d7fbd0fd70289182e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260fecda6a32bfc24e16a950e7d91559"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a260fecda6a32bfc24e16a950e7d91559">PrintPacketTags</a> (std::ostream &amp;os) const </td></tr>
<tr class="separator:a260fecda6a32bfc24e16a950e7d91559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a06a61555a35fcad20638e6a7dfbeaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classns3_1_1_packet_tag_iterator.html">PacketTagIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a9a06a61555a35fcad20638e6a7dfbeaa">GetPacketTagIterator</a> (void) const </td></tr>
<tr class="separator:a9a06a61555a35fcad20638e6a7dfbeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a461d27ef5955a9499a5c491527787d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a3a461d27ef5955a9499a5c491527787d">SetNixVector</a> (<a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_nix_vector.html">NixVector</a> &gt;)</td></tr>
<tr class="separator:a3a461d27ef5955a9499a5c491527787d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d68d7d2738678185315b59640848819"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_nix_vector.html">NixVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a3d68d7d2738678185315b59640848819">GetNixVector</a> (void) const </td></tr>
<tr class="separator:a3d68d7d2738678185315b59640848819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f70d7b6b22cf05706cdc25c44044e1c"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a5f70d7b6b22cf05706cdc25c44044e1c">GetBuffer</a> () const </td></tr>
<tr class="separator:a5f70d7b6b22cf05706cdc25c44044e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classns3_1_1_simple_ref_count"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classns3_1_1_simple_ref_count')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classns3_1_1_simple_ref_count.html">ns3::SimpleRefCount&lt; Packet &gt;</a></td></tr>
<tr class="memitem:a63d5f45f3abdac2f6766eded32e37e93 inherit pub_methods_classns3_1_1_simple_ref_count"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_simple_ref_count.html#a63d5f45f3abdac2f6766eded32e37e93">SimpleRefCount</a> ()</td></tr>
<tr class="memdesc:a63d5f45f3abdac2f6766eded32e37e93 inherit pub_methods_classns3_1_1_simple_ref_count"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a63d5f45f3abdac2f6766eded32e37e93">More...</a><br/></td></tr>
<tr class="separator:a63d5f45f3abdac2f6766eded32e37e93 inherit pub_methods_classns3_1_1_simple_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8002cfa9c03b4cae0e0ac38a78cc931 inherit pub_methods_classns3_1_1_simple_ref_count"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_simple_ref_count.html#ac8002cfa9c03b4cae0e0ac38a78cc931">SimpleRefCount</a> (const <a class="el" href="classns3_1_1_simple_ref_count.html">SimpleRefCount</a> &amp;o)</td></tr>
<tr class="memdesc:ac8002cfa9c03b4cae0e0ac38a78cc931 inherit pub_methods_classns3_1_1_simple_ref_count"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#ac8002cfa9c03b4cae0e0ac38a78cc931">More...</a><br/></td></tr>
<tr class="separator:ac8002cfa9c03b4cae0e0ac38a78cc931 inherit pub_methods_classns3_1_1_simple_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabdd2ee9bd71a8d7b886cd570a7ffdad inherit pub_methods_classns3_1_1_simple_ref_count"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classns3_1_1_simple_ref_count.html">SimpleRefCount</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_simple_ref_count.html#aabdd2ee9bd71a8d7b886cd570a7ffdad">operator=</a> (const <a class="el" href="classns3_1_1_simple_ref_count.html">SimpleRefCount</a> &amp;o)</td></tr>
<tr class="memdesc:aabdd2ee9bd71a8d7b886cd570a7ffdad inherit pub_methods_classns3_1_1_simple_ref_count"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment.  <a href="#aabdd2ee9bd71a8d7b886cd570a7ffdad">More...</a><br/></td></tr>
<tr class="separator:aabdd2ee9bd71a8d7b886cd570a7ffdad inherit pub_methods_classns3_1_1_simple_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7545a4e56ceef44cb91e2bbf0f26f18 inherit pub_methods_classns3_1_1_simple_ref_count"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_simple_ref_count.html#ab7545a4e56ceef44cb91e2bbf0f26f18">Ref</a> (void) const</td></tr>
<tr class="memdesc:ab7545a4e56ceef44cb91e2bbf0f26f18 inherit pub_methods_classns3_1_1_simple_ref_count"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the reference count.  <a href="#ab7545a4e56ceef44cb91e2bbf0f26f18">More...</a><br/></td></tr>
<tr class="separator:ab7545a4e56ceef44cb91e2bbf0f26f18 inherit pub_methods_classns3_1_1_simple_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8f59b2f744915a64a2271c9e4b5ec0 inherit pub_methods_classns3_1_1_simple_ref_count"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_simple_ref_count.html#aeb8f59b2f744915a64a2271c9e4b5ec0">Unref</a> (void) const</td></tr>
<tr class="memdesc:aeb8f59b2f744915a64a2271c9e4b5ec0 inherit pub_methods_classns3_1_1_simple_ref_count"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the reference count.  <a href="#aeb8f59b2f744915a64a2271c9e4b5ec0">More...</a><br/></td></tr>
<tr class="separator:aeb8f59b2f744915a64a2271c9e4b5ec0 inherit pub_methods_classns3_1_1_simple_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05378396c93bcc7d6bf78a9ee9ae9cca inherit pub_methods_classns3_1_1_simple_ref_count"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_simple_ref_count.html#a05378396c93bcc7d6bf78a9ee9ae9cca">GetReferenceCount</a> (void) const</td></tr>
<tr class="memdesc:a05378396c93bcc7d6bf78a9ee9ae9cca inherit pub_methods_classns3_1_1_simple_ref_count"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reference count of the object.  <a href="#a05378396c93bcc7d6bf78a9ee9ae9cca">More...</a><br/></td></tr>
<tr class="separator:a05378396c93bcc7d6bf78a9ee9ae9cca inherit pub_methods_classns3_1_1_simple_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae17c0cd8e63e83df3c9273801e3d5d7f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#ae17c0cd8e63e83df3c9273801e3d5d7f">EnablePrinting</a> (void)</td></tr>
<tr class="memdesc:ae17c0cd8e63e83df3c9273801e3d5d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default, packets do not keep around enough metadata to perform the operations requested by the Print methods.  <a href="#ae17c0cd8e63e83df3c9273801e3d5d7f">More...</a><br/></td></tr>
<tr class="separator:ae17c0cd8e63e83df3c9273801e3d5d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6564e3496f2b8852774c98bd839b85"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#abf6564e3496f2b8852774c98bd839b85">EnableChecking</a> (void)</td></tr>
<tr class="memdesc:abf6564e3496f2b8852774c98bd839b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">The packet metadata is also used to perform extensive sanity checks at runtime when performing operations on a <a class="el" href="classns3_1_1_packet.html" title="network packets ">Packet</a>.  <a href="#abf6564e3496f2b8852774c98bd839b85">More...</a><br/></td></tr>
<tr class="separator:abf6564e3496f2b8852774c98bd839b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classns3_1_1_simple_ref_count"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classns3_1_1_simple_ref_count')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classns3_1_1_simple_ref_count.html">ns3::SimpleRefCount&lt; Packet &gt;</a></td></tr>
<tr class="memitem:aa2018cc60e813893af32650e1e37a857 inherit pub_static_methods_classns3_1_1_simple_ref_count"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_simple_ref_count.html#aa2018cc60e813893af32650e1e37a857">Cleanup</a> (void)</td></tr>
<tr class="memdesc:aa2018cc60e813893af32650e1e37a857 inherit pub_static_methods_classns3_1_1_simple_ref_count"><td class="mdescLeft">&#160;</td><td class="mdescRight">Noop.  <a href="#aa2018cc60e813893af32650e1e37a857">More...</a><br/></td></tr>
<tr class="separator:aa2018cc60e813893af32650e1e37a857 inherit pub_static_methods_classns3_1_1_simple_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aac8558f4df4ea72feeaa7556a9cb1708"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#aac8558f4df4ea72feeaa7556a9cb1708">Packet</a> (const <a class="el" href="classns3_1_1_buffer.html">Buffer</a> &amp;buffer, const <a class="el" href="classns3_1_1_byte_tag_list.html">ByteTagList</a> &amp;byteTagList, const <a class="el" href="classns3_1_1_packet_tag_list.html">PacketTagList</a> &amp;packetTagList, const <a class="el" href="classns3_1_1_packet_metadata.html">PacketMetadata</a> &amp;metadata)</td></tr>
<tr class="separator:aac8558f4df4ea72feeaa7556a9cb1708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196f5609e8b04efef405cab130612151"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a196f5609e8b04efef405cab130612151">Deserialize</a> (uint8_t const *buffer, uint32_t size)</td></tr>
<tr class="separator:a196f5609e8b04efef405cab130612151"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a0f17bc9b4177865c9fe48fc927d57996"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classns3_1_1_buffer.html">Buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a0f17bc9b4177865c9fe48fc927d57996">m_buffer</a></td></tr>
<tr class="separator:a0f17bc9b4177865c9fe48fc927d57996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e08c3cc4220a80366eea801c00e4ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classns3_1_1_byte_tag_list.html">ByteTagList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a29e08c3cc4220a80366eea801c00e4ba">m_byteTagList</a></td></tr>
<tr class="separator:a29e08c3cc4220a80366eea801c00e4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c91fc548c7cfddf27c176e13bd858ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classns3_1_1_packet_tag_list.html">PacketTagList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a7c91fc548c7cfddf27c176e13bd858ff">m_packetTagList</a></td></tr>
<tr class="separator:a7c91fc548c7cfddf27c176e13bd858ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f95fba7966191bd152bcedd5fbcd6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classns3_1_1_packet_metadata.html">PacketMetadata</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#af3f95fba7966191bd152bcedd5fbcd6b">m_metadata</a></td></tr>
<tr class="separator:af3f95fba7966191bd152bcedd5fbcd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fe17f2fb778ccd84af5c3c950ee4f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_nix_vector.html">NixVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#af6fe17f2fb778ccd84af5c3c950ee4f4">m_nixVector</a></td></tr>
<tr class="separator:af6fe17f2fb778ccd84af5c3c950ee4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a4f707aab2b31689f8d1dadaed31e7c82"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_packet.html#a4f707aab2b31689f8d1dadaed31e7c82">m_globalUid</a> = 0</td></tr>
<tr class="separator:a4f707aab2b31689f8d1dadaed31e7c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>network packets </p>
<p>Each network packet contains a byte buffer, a set of byte tags, a set of packet tags, and metadata.</p>
<ul>
<li>The byte buffer stores the serialized content of the headers and trailers added to a packet. The serialized representation of these headers is expected to match that of real network packets bit for bit (although nothing forces you to do this) which means that the content of a packet buffer is expected to be that of a real packet.</li>
<li>The metadata describes the type of the headers and trailers which were serialized in the byte buffer. The maintenance of metadata is optional and disabled by default. To enable it, you must call <a class="el" href="classns3_1_1_packet.html#ae17c0cd8e63e83df3c9273801e3d5d7f" title="By default, packets do not keep around enough metadata to perform the operations requested by the Pri...">Packet::EnablePrinting</a> and this will allow you to get non-empty output from <a class="el" href="classns3_1_1_packet.html#aa34058a5cdbf94673531f8c4001ab227">Packet::Print</a>. If you wish to only enable checking of metadata, and do not need any printing capability, you can call <a class="el" href="classns3_1_1_packet.html#abf6564e3496f2b8852774c98bd839b85" title="The packet metadata is also used to perform extensive sanity checks at runtime when performing operat...">Packet::EnableChecking</a>: its runtime cost is lower than <a class="el" href="classns3_1_1_packet.html#ae17c0cd8e63e83df3c9273801e3d5d7f" title="By default, packets do not keep around enough metadata to perform the operations requested by the Pri...">Packet::EnablePrinting</a>.</li>
<li>The set of tags contain simulation-specific information which cannot be stored in the packet byte buffer because the protocol headers or trailers have no standard-conformant field for this information. So-called 'byte' tags are used to tag a subset of the bytes in the packet byte buffer while 'packet' tags are used to tag the packet itself. The main difference between these two kinds of tags is what happens when packets are copied, fragmented, and reassembled: 'byte' tags follow bytes while 'packet' tags follow packets. Another important difference between these two kinds of tags is that byte tags cannot be removed and are expected to be written once, and read many times, while packet tags are expected to be written once, read many times, and removed exactly once. An example of a 'byte' tag is a <a class="el" href="classns3_1_1_flow_id_tag.html">FlowIdTag</a> which contains a flow id and is set by the application generating traffic. An example of a 'packet' tag is a cross-layer qos class id set by an application and processed by a lower-level MAC layer.</li>
</ul>
<p>Implementing a new type of <a class="el" href="classns3_1_1_header.html" title="Protocol header serialization and deserialization. ">Header</a> or <a class="el" href="classns3_1_1_trailer.html" title="Protocol trailer serialization and deserialization. ">Trailer</a> for a new protocol is pretty easy and is a matter of creating a subclass of the <a class="el" href="classns3_1_1_header.html" title="Protocol header serialization and deserialization. ">ns3::Header</a> or of the <a class="el" href="classns3_1_1_trailer.html" title="Protocol trailer serialization and deserialization. ">ns3::Trailer</a> base class, and implementing the methods described in their respective API documentation.</p>
<p>Implementing a new type of <a class="el" href="classns3_1_1_tag.html" title="tag a set of bytes in a packet ">Tag</a> requires roughly the same amount of work and this work is described in the <a class="el" href="classns3_1_1_tag.html" title="tag a set of bytes in a packet ">ns3::Tag</a> API documentation.</p>
<p>The performance aspects of the <a class="el" href="classns3_1_1_packet.html" title="network packets ">Packet</a> API are discussed in <a class="el" href="group__packetperf.html">Packet Performance</a> </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac1a30f8cf28346960cfac4a2c9fa7026"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ns3::Packet::Packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an empty packet with a new uid (as returned by getUid). </p>

</div>
</div>
<a class="anchor" id="aa8b64449ccabad33e9e61c70e06db166"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ns3::Packet::Packet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classns3_1_1_packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a897aab15901dcf1f05f075db7b8d04b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ns3::Packet::Packet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a packet with a zero-filled payload. </p>
<p>The memory necessary for the payload is not allocated: it will be allocated at any later point if you attempt to fragment this packet or to access the zero-filled bytes. The packet is allocated with a new uid (as returned by getUid).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the size of the zero-filled payload </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2d46939241156115411e66aa1a65f09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ns3::Packet::Packet </td>
          <td>(</td>
          <td class="paramtype">uint8_t const *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>magic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new packet from the serialized buffer. </p>
<p>This new packet is identical to the serialized packet contained in the buffer and is magically deserialized for you</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the serialized packet to be created </td></tr>
    <tr><td class="paramname">size</td><td>the size of the packet for deserialization </td></tr>
    <tr><td class="paramname">magic</td><td>allows packet deserialization; asserts when set to false </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f6a0314efee85ac6cf4a64e05450538"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ns3::Packet::Packet </td>
          <td>(</td>
          <td class="paramtype">uint8_t const *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a packet with payload filled with the content of this buffer. </p>
<p>The input data is copied: the input buffer is untouched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the data to store in the packet. </td></tr>
    <tr><td class="paramname">size</td><td>the size of the input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac8558f4df4ea72feeaa7556a9cb1708"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ns3::Packet::Packet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classns3_1_1_buffer.html">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classns3_1_1_byte_tag_list.html">ByteTagList</a> &amp;&#160;</td>
          <td class="paramname"><em>byteTagList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classns3_1_1_packet_tag_list.html">PacketTagList</a> &amp;&#160;</td>
          <td class="paramname"><em>packetTagList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classns3_1_1_packet_metadata.html">PacketMetadata</a> &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a14ec3d4250b425468764de58f5837b6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Packet::AddAtEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; const <a class="el" href="classns3_1_1_packet.html">Packet</a> &gt;&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate the input packet at the end of the current packet. </p>
<p>This does not alter the uid of either packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>packet to concatenate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad5997caea8c22757acade2fcb4d7daca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Packet::AddByteTag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classns3_1_1_tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the new tag to add to this packet</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classns3_1_1_tag.html" title="tag a set of bytes in a packet ">Tag</a> each byte included in this packet with the new tag.</p>
<p>Note that adding a tag is a const operation which is pretty un-intuitive. The rationale is that the content and behavior of a packet is <em>not</em> changed when a tag is added to a packet: any code which was not aware of the new tag is going to work just the same if the new tag is added. The real reason why adding a tag was made a const operation is to allow a trace sink which gets a packet to tag the packet, even if the packet is const (and most trace sources should use const packets because it would be totally evil to allow a trace sink to modify the content of a packet). </p>

</div>
</div>
<a class="anchor" id="a465108c595a0bc592095cbcab1832ed8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Packet::AddHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classns3_1_1_header.html">Header</a> &amp;&#160;</td>
          <td class="paramname"><em>header</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add header to this packet. </p>
<p>This method invokes the <a class="el" href="classns3_1_1_header.html#a6ef0497eabc1b1fb0ad42738eb73f934">Header::GetSerializedSize</a> and <a class="el" href="classns3_1_1_header.html#afb61f1aac69ff8349a6bfe521fab5404">Header::Serialize</a> methods to reserve space in the buffer and request the header to serialize itself in the packet buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td>a reference to the header to add to this packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7400b8655852f5271c5957250d0141af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Packet::AddPacketTag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classns3_1_1_tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag to store in this packet</td></tr>
  </table>
  </dd>
</dl>
<p>Add a tag to this packet. This method calls the <a class="el" href="classns3_1_1_tag.html#a01c8efdea943fd8cce2ef5d4d67eefa6">Tag::GetSerializedSize</a> and, then, <a class="el" href="classns3_1_1_tag.html#ac9aa7c4f923da5d2c82de94690101dc3">Tag::Serialize</a>.</p>
<p>Note that this method is const, that is, it does not modify the state of this packet, which is fairly un-intuitive. </p>

</div>
</div>
<a class="anchor" id="ae964f1fcfd496c6c0db1b73f27e78530"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Packet::AddPaddingAtEnd </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>number of padding bytes to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae26b490c30ae5bc98be5181ec6e06db8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Packet::AddTrailer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classns3_1_1_trailer.html">Trailer</a> &amp;&#160;</td>
          <td class="paramname"><em>trailer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add trailer to this packet. </p>
<p>This method invokes the <a class="el" href="classns3_1_1_trailer.html#a6af7be196bad576c3601e267b0637ff7">Trailer::GetSerializedSize</a> and <a class="el" href="classns3_1_1_trailer.html#a160451b2ded3a615b1ccfa25ab60c2e3">Trailer::Serialize</a> methods to reserve space in the buffer and request the trailer to serialize itself in the packet buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trailer</td><td>a reference to the trailer to add to this packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0951ffaa12e116b03c4888085280501d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classns3_1_1_packet_metadata_1_1_item_iterator.html">PacketMetadata::ItemIterator</a> ns3::Packet::BeginItem </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an iterator which points to the first 'item' stored in this buffer. Note that this iterator will point to an empty array of items if you don't call EnablePrinting or EnableChecking before.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classns3_1_1_packet.html#ae17c0cd8e63e83df3c9273801e3d5d7f" title="By default, packets do not keep around enough metadata to perform the operations requested by the Pri...">EnablePrinting</a> <a class="el" href="classns3_1_1_packet.html#abf6564e3496f2b8852774c98bd839b85" title="The packet metadata is also used to perform extensive sanity checks at runtime when performing operat...">EnableChecking</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5d5c70802a5f77fc5f0001e0cfc1898b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_packet.html">Packet</a> &gt; ns3::Packet::Copy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a COW copy of the packet.</dd></dl>
<p>The returns packet will behave like an independent copy of the original packet, even though they both share the same datasets internally. </p>

</div>
</div>
<a class="anchor" id="a5a6d304b9e0d90733919ffe224b98f0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ns3::Packet::CopyData </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>a pointer to a byte buffer where the packet data should be copied. </td></tr>
    <tr><td class="paramname">size</td><td>the size of the byte buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes read from the packet</dd></dl>
<p>No more than <b>size</b> bytes will be copied by this function. </p>

</div>
</div>
<a class="anchor" id="a62f6ad90367d0f86db3a5f39589c6897"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Packet::CopyData </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>pointer to output stream in which we want to write the packet data. </td></tr>
    <tr><td class="paramname">size</td><td>the maximum number of bytes we want to write in the output stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16f6113606b355b2b346e2245fa2a3d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_packet.html">Packet</a> &gt; ns3::Packet::CreateFragment </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new packet which contains a fragment of the original packet. </p>
<p>The returned packet shares the same uid as this packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>offset from start of packet to start of fragment to create </td></tr>
    <tr><td class="paramname">length</td><td>length of fragment to create </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a fragment of the original packet </dd></dl>

</div>
</div>
<a class="anchor" id="a196f5609e8b04efef405cab130612151"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ns3::Packet::Deserialize </td>
          <td>(</td>
          <td class="paramtype">uint8_t const *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abf6564e3496f2b8852774c98bd839b85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Packet::EnableChecking </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The packet metadata is also used to perform extensive sanity checks at runtime when performing operations on a <a class="el" href="classns3_1_1_packet.html" title="network packets ">Packet</a>. </p>
<p>For example, this metadata is used to verify that when you remove a header from a packet, this same header was actually present at the front of the packet. These errors will be detected and will abort the program. </p>

</div>
</div>
<a class="anchor" id="ae17c0cd8e63e83df3c9273801e3d5d7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Packet::EnablePrinting </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>By default, packets do not keep around enough metadata to perform the operations requested by the Print methods. </p>
<p>If you want to be able the <a class="el" href="classns3_1_1_packet.html#aa34058a5cdbf94673531f8c4001ab227">Packet::Print</a> method, you need to invoke this method at least once during the simulation setup and before any packet is created. </p>

</div>
</div>
<a class="anchor" id="a2e1403c2411495827012fe000823c16a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ns3::Packet::FindFirstMatchingByteTag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classns3_1_1_tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag to search in this packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the requested tag type was found, false otherwise.</dd></dl>
<p>If the requested tag type is found, it is copied in the user's provided tag instance. </p>

</div>
</div>
<a class="anchor" id="a5f70d7b6b22cf05706cdc25c44044e1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * ns3::Packet::GetBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3c03f35c267e8534c29bdaa4686e4823"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classns3_1_1_byte_tag_iterator.html">ByteTagIterator</a> ns3::Packet::GetByteTagIterator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an iterator over the set of byte tags included in this packet. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d68d7d2738678185315b59640848819"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_nix_vector.html">NixVector</a> &gt; ns3::Packet::GetNixVector </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9a06a61555a35fcad20638e6a7dfbeaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classns3_1_1_packet_tag_iterator.html">PacketTagIterator</a> ns3::Packet::GetPacketTagIterator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an object which can be used to iterate over the list of packet tags. </dd></dl>

</div>
</div>
<a class="anchor" id="a7416c3bc8c1a9a86c8ade4dfd1d67d2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ns3::Packet::GetSerializedSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For packet serializtion, the total size is checked in order to determine the size of the buffer required for serialization. </p>
<dl class="section return"><dt>Returns</dt><dd>number of bytes required for packet serialization </dd></dl>

</div>
</div>
<a class="anchor" id="a462855c9929954d4301a4edfe55f4f1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ns3::Packet::GetSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the size in bytes of the packet (including the zero-filled initial payload) </dd></dl>

</div>
</div>
<a class="anchor" id="a1f212c825b50e54d94f5b9ae99592e6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ns3::Packet::GetUid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_a.html">A</a> packet is allocated a new uid when it is created empty or with zero-filled payload. </p>
<p>Note: This uid is an internal uid and cannot be counted on to provide an accurate counter of how many "simulated packets" of a particular protocol are in the system. It is not trivial to make this uid into such a counter, because of questions such as what should the uid be when the packet is sent over broadcast media, or when fragmentation occurs. If a user wants to trace actual packet counts, he or she should look at e.g. the IP ID field or transport sequence numbers, or other packet or frame counters at other protocol layers.</p>
<dl class="section return"><dt>Returns</dt><dd>an integer identifier which uniquely identifies this packet. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f7627bc5113f3fa52ad68a20d57aa94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classns3_1_1_packet.html">Packet</a> &amp; ns3::Packet::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classns3_1_1_packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaed76e440db303a3f2487a4c6f805adf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t const * ns3::Packet::PeekData </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If you try to change the content of the buffer returned by this method, you will die. </p>
<p>Note that this method is now deprecated and will be removed in the next version of ns-3. If you need to get access to the content of the byte buffer of a packet, you need to call <a class="el" href="classns3_1_1_packet.html#a5a6d304b9e0d90733919ffe224b98f0d">ns3::Packet::CopyData</a> to perform an explicit copy.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the internal buffer of the packet. </dd></dl>

</div>
</div>
<a class="anchor" id="aadc63487bea70945c418f4c3e9b81964"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ns3::Packet::PeekHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classns3_1_1_header.html">Header</a> &amp;&#160;</td>
          <td class="paramname"><em>header</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialize but does <em>not</em> remove the header from the internal buffer. </p>
<p>This method invokes <a class="el" href="classns3_1_1_header.html#a78be9400bb66b2a8543606f395ef5396">Header::Deserialize</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td>a reference to the header to read from the internal buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes read from the packet. </dd></dl>

</div>
</div>
<a class="anchor" id="a1734de11f2ca1e78a7872461a0625168"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ns3::Packet::PeekPacketTag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classns3_1_1_tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag to search in this packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the requested tag is found, false otherwise.</dd></dl>
<p>Search a matching tag and call <a class="el" href="classns3_1_1_tag.html#ae166b7f816bcbdef44dbeb636c9fa712">Tag::Deserialize</a> if it is found. </p>

</div>
</div>
<a class="anchor" id="ace1fc287b3fc4fc12e72954e35342131"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ns3::Packet::PeekTrailer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classns3_1_1_trailer.html">Trailer</a> &amp;&#160;</td>
          <td class="paramname"><em>trailer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialize but does <em>not</em> remove a trailer from the internal buffer. </p>
<p>This method invokes the <a class="el" href="classns3_1_1_trailer.html#aed0f0292faca43ef8676c05d70a664cf">Trailer::Deserialize</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trailer</td><td>a reference to the trailer to read from the internal buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes read from the end of the packet. </dd></dl>

</div>
</div>
<a class="anchor" id="aa34058a5cdbf94673531f8c4001ab227"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Packet::Print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream in which the data should be printed.</td></tr>
  </table>
  </dd>
</dl>
<p>Iterate over the headers and trailers present in this packet, from the first header to the last trailer and invoke, for each of them, the user-provided method Header::DoPrint or Trailer::DoPrint methods. </p>

</div>
</div>
<a class="anchor" id="af3766d81feb51b754cb036526c2f4366"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Packet::PrintByteTags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream in which the data should be printed.</td></tr>
  </table>
  </dd>
</dl>
<p>Iterate over the tags present in this packet, and invoke the Print method of each tag stored in the packet. </p>

</div>
</div>
<a class="anchor" id="a260fecda6a32bfc24e16a950e7d91559"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Packet::PrintPacketTags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the stream in which we want to print data.</td></tr>
  </table>
  </dd>
</dl>
<p>Print the list of 'packet' tags.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classns3_1_1_packet.html#a7400b8655852f5271c5957250d0141af">Packet::AddPacketTag</a>, <a class="el" href="classns3_1_1_packet.html#a078fe922d976a417ab25ba2f3c2fd667">Packet::RemovePacketTag</a>, <a class="el" href="classns3_1_1_packet.html#a1734de11f2ca1e78a7872461a0625168">Packet::PeekPacketTag</a>, <a class="el" href="classns3_1_1_packet.html#a6c7bc5d1067c1d7fbd0fd70289182e8b" title="Remove all packet tags. ">Packet::RemoveAllPacketTags</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a083f54c9db31aeff30551a9e20fcda42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Packet::RemoveAllByteTags </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all the tags stored in this packet. </p>

</div>
</div>
<a class="anchor" id="a6c7bc5d1067c1d7fbd0fd70289182e8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Packet::RemoveAllPacketTags </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all packet tags. </p>

</div>
</div>
<a class="anchor" id="a607de6c1abda2a960e99a3b59fd35d14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Packet::RemoveAtEnd </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove size bytes from the end of the current packet It is safe to remove more bytes that what is present in the packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>number of bytes from remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78aa207e7921dd2f9f7e0d0b7a1c730a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Packet::RemoveAtStart </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove size bytes from the start of the current packet. </p>
<p>It is safe to remove more bytes that what is present in the packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>number of bytes from remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0961eccf975d75f902d40956c93ba63e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ns3::Packet::RemoveHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classns3_1_1_header.html">Header</a> &amp;&#160;</td>
          <td class="paramname"><em>header</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialize and remove the header from the internal buffer. </p>
<p>This method invokes <a class="el" href="classns3_1_1_header.html#a78be9400bb66b2a8543606f395ef5396">Header::Deserialize</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td>a reference to the header to remove from the internal buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes removed from the packet. </dd></dl>

</div>
</div>
<a class="anchor" id="a078fe922d976a417ab25ba2f3c2fd667"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ns3::Packet::RemovePacketTag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classns3_1_1_tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag to remove from this packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the requested tag is found, false otherwise.</dd></dl>
<p>Remove a tag from this packet. This method calls <a class="el" href="classns3_1_1_tag.html#ae166b7f816bcbdef44dbeb636c9fa712">Tag::Deserialize</a> if the tag is found. </p>

</div>
</div>
<a class="anchor" id="a2155e042083e9a17ad3b33f9fecb4be4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ns3::Packet::RemoveTrailer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classns3_1_1_trailer.html">Trailer</a> &amp;&#160;</td>
          <td class="paramname"><em>trailer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a deserialized trailer from the internal buffer. </p>
<p>This method invokes the Deserialize method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trailer</td><td>a reference to the trailer to remove from the internal buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes removed from the end of the packet. </dd></dl>

</div>
</div>
<a class="anchor" id="a939e41b065c6f9f77d3f51373baeaf7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ns3::Packet::Serialize </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3a461d27ef5955a9499a5c491527787d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Packet::SetNixVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_nix_vector.html">NixVector</a> &gt;&#160;</td>
          <td class="paramname"><em>nixVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a0f17bc9b4177865c9fe48fc927d57996"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classns3_1_1_buffer.html">Buffer</a> ns3::Packet::m_buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a29e08c3cc4220a80366eea801c00e4ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classns3_1_1_byte_tag_list.html">ByteTagList</a> ns3::Packet::m_byteTagList</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4f707aab2b31689f8d1dadaed31e7c82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ns3::Packet::m_globalUid = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af3f95fba7966191bd152bcedd5fbcd6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classns3_1_1_packet_metadata.html">PacketMetadata</a> ns3::Packet::m_metadata</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af6fe17f2fb778ccd84af5c3c950ee4f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt;<a class="el" href="classns3_1_1_nix_vector.html">NixVector</a>&gt; ns3::Packet::m_nixVector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7c91fc548c7cfddf27c176e13bd858ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classns3_1_1_packet_tag_list.html">PacketTagList</a> ns3::Packet::m_packetTagList</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacens3.html">ns3</a></li><li class="navelem"><a class="el" href="classns3_1_1_packet.html">Packet</a></li>
    <li class="footer">Generated on Thu May 16 2024 11:27:10 for My Project by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>

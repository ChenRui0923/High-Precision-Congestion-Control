<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>My Project: ns3::Names Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   &#160;<span id="projectnumber">beta 0.01</span>
   </div>
   <div id="projectbrief">Doxygen for HPCC-plus</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classns3_1_1_names.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="classns3_1_1_names-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ns3::Names Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_a.html">A</a> directory of name and Ptr&lt;Object&gt; associations that allows us to give any <a class="el" href="namespacens3.html" title="The implementation of the public static-based API which calls into the private implementation through...">ns3</a> <a class="el" href="classns3_1_1_object.html" title="a base class which provides memory management and object aggregation ">Object</a> a name.  
 <a href="classns3_1_1_names.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="names_8h_source.html">names.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5075ee36f97059d897cf6430ce61e592"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_names.html#a5075ee36f97059d897cf6430ce61e592">Add</a> (std::string <a class="el" href="generate__test__data__lte__spectrum__model_8m.html#ab74e6bf80237ddc4109968cedc58c151">name</a>, <a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt; object)</td></tr>
<tr class="memdesc:a5075ee36f97059d897cf6430ce61e592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the association between the string "name" and the Ptr&lt;Object&gt; obj.  <a href="#a5075ee36f97059d897cf6430ce61e592">More...</a><br/></td></tr>
<tr class="separator:a5075ee36f97059d897cf6430ce61e592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a251b61a3a52abf2c138c7bddcc0024"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_names.html#a1a251b61a3a52abf2c138c7bddcc0024">Add</a> (std::string path, std::string <a class="el" href="generate__test__data__lte__spectrum__model_8m.html#ab74e6bf80237ddc4109968cedc58c151">name</a>, <a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt; object)</td></tr>
<tr class="memdesc:a1a251b61a3a52abf2c138c7bddcc0024"><td class="mdescLeft">&#160;</td><td class="mdescRight">An intermediate form of <a class="el" href="classns3_1_1_names.html#a5075ee36f97059d897cf6430ce61e592" title="Add the association between the string &quot;name&quot; and the Ptr&lt;Object&gt; obj. ">Names::Add</a> allowing you to provide a path to the parent object (under which you want this name to be defined) in the form of a name path string.  <a href="#a1a251b61a3a52abf2c138c7bddcc0024">More...</a><br/></td></tr>
<tr class="separator:a1a251b61a3a52abf2c138c7bddcc0024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e958166cb8296bc0fa035668d83040"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_names.html#a93e958166cb8296bc0fa035668d83040">Add</a> (<a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt; context, std::string <a class="el" href="generate__test__data__lte__spectrum__model_8m.html#ab74e6bf80237ddc4109968cedc58c151">name</a>, <a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt; object)</td></tr>
<tr class="memdesc:a93e958166cb8296bc0fa035668d83040"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_a.html">A</a> low-level form of <a class="el" href="classns3_1_1_names.html#a5075ee36f97059d897cf6430ce61e592" title="Add the association between the string &quot;name&quot; and the Ptr&lt;Object&gt; obj. ">Names::Add</a> allowing you to specify the path to the parent object (under which you want this name to be defined) in the form of a previously named object.  <a href="#a93e958166cb8296bc0fa035668d83040">More...</a><br/></td></tr>
<tr class="separator:a93e958166cb8296bc0fa035668d83040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed4aa6358357bef3930cd19ba306373"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_names.html#a0ed4aa6358357bef3930cd19ba306373">Rename</a> (std::string oldpath, std::string newname)</td></tr>
<tr class="memdesc:a0ed4aa6358357bef3930cd19ba306373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename a previously associated name.  <a href="#a0ed4aa6358357bef3930cd19ba306373">More...</a><br/></td></tr>
<tr class="separator:a0ed4aa6358357bef3930cd19ba306373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7b8a3e5e9423ef8c61d6ad216ca81c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_names.html#a8e7b8a3e5e9423ef8c61d6ad216ca81c">Rename</a> (std::string path, std::string oldname, std::string newname)</td></tr>
<tr class="memdesc:a8e7b8a3e5e9423ef8c61d6ad216ca81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An intermediate form of <a class="el" href="classns3_1_1_names.html#a0ed4aa6358357bef3930cd19ba306373" title="Rename a previously associated name. ">Names::Rename</a> allowing you to provide a path to the parent object (under which you want this name to be changed) in the form of a name path string.  <a href="#a8e7b8a3e5e9423ef8c61d6ad216ca81c">More...</a><br/></td></tr>
<tr class="separator:a8e7b8a3e5e9423ef8c61d6ad216ca81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6474f8c16e99575397c5c243a3f9aa4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_names.html#ad6474f8c16e99575397c5c243a3f9aa4">Rename</a> (<a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt; context, std::string oldname, std::string newname)</td></tr>
<tr class="memdesc:ad6474f8c16e99575397c5c243a3f9aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_a.html">A</a> low-level form of <a class="el" href="classns3_1_1_names.html#a0ed4aa6358357bef3930cd19ba306373" title="Rename a previously associated name. ">Names::Rename</a> allowing you to specify the path to the parent object (under which you want this name to be changed) in the form of a previously named object.  <a href="#ad6474f8c16e99575397c5c243a3f9aa4">More...</a><br/></td></tr>
<tr class="separator:ad6474f8c16e99575397c5c243a3f9aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9664faf23569aaae64a2d1f65265045"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_names.html#ab9664faf23569aaae64a2d1f65265045">FindName</a> (<a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt; object)</td></tr>
<tr class="memdesc:ab9664faf23569aaae64a2d1f65265045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a pointer to an object, look to see if that object has a name associated with it and, if so, return the name of the object otherwise return an empty string.  <a href="#ab9664faf23569aaae64a2d1f65265045">More...</a><br/></td></tr>
<tr class="separator:ab9664faf23569aaae64a2d1f65265045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72bee5ceb8c2592ef37063311501498"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_names.html#af72bee5ceb8c2592ef37063311501498">FindPath</a> (<a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt; object)</td></tr>
<tr class="memdesc:af72bee5ceb8c2592ef37063311501498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a pointer to an object, look to see if that object has a name associated with it and return the fully qualified name path of the object otherwise return an empty string.  <a href="#af72bee5ceb8c2592ef37063311501498">More...</a><br/></td></tr>
<tr class="separator:af72bee5ceb8c2592ef37063311501498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda77642452c3e4a4ad8a76491dd2538"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_names.html#abda77642452c3e4a4ad8a76491dd2538">Clear</a> (void)</td></tr>
<tr class="memdesc:abda77642452c3e4a4ad8a76491dd2538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the list of objects associated with names.  <a href="#abda77642452c3e4a4ad8a76491dd2538">More...</a><br/></td></tr>
<tr class="separator:abda77642452c3e4a4ad8a76491dd2538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d07094fb3d716d08733af05c1593555"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d07094fb3d716d08733af05c1593555"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classns3_1_1_names.html#a9d07094fb3d716d08733af05c1593555">Find</a> (std::string path)</td></tr>
<tr class="memdesc:a9d07094fb3d716d08733af05c1593555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a name path string, look to see if there's an object in the system with that associated to it.  <a href="#a9d07094fb3d716d08733af05c1593555">More...</a><br/></td></tr>
<tr class="separator:a9d07094fb3d716d08733af05c1593555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9baba3c4fe189b9e2c493df9e70697"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5d9baba3c4fe189b9e2c493df9e70697"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classns3_1_1_names.html#a5d9baba3c4fe189b9e2c493df9e70697">Find</a> (std::string path, std::string <a class="el" href="generate__test__data__lte__spectrum__model_8m.html#ab74e6bf80237ddc4109968cedc58c151">name</a>)</td></tr>
<tr class="memdesc:a5d9baba3c4fe189b9e2c493df9e70697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a path to an object and an object name, look through the names defined under the path to see if there's an object there with the given name.  <a href="#a5d9baba3c4fe189b9e2c493df9e70697">More...</a><br/></td></tr>
<tr class="separator:a5d9baba3c4fe189b9e2c493df9e70697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2851cf2c04306722f838f37430d93f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7d2851cf2c04306722f838f37430d93f"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classns3_1_1_names.html#a7d2851cf2c04306722f838f37430d93f">Find</a> (<a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt; context, std::string <a class="el" href="generate__test__data__lte__spectrum__model_8m.html#ab74e6bf80237ddc4109968cedc58c151">name</a>)</td></tr>
<tr class="memdesc:a7d2851cf2c04306722f838f37430d93f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a path to an object and an object name, look through the names defined under the path to see if there's an object there with the given name.  <a href="#a7d2851cf2c04306722f838f37430d93f">More...</a><br/></td></tr>
<tr class="separator:a7d2851cf2c04306722f838f37430d93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a1d022d5483c79de459ce17e89d98d3f4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_names.html#a1d022d5483c79de459ce17e89d98d3f4">FindInternal</a> (std::string path)</td></tr>
<tr class="separator:a1d022d5483c79de459ce17e89d98d3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429d750ca5b03823d6dea2ed3476b3ab"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_names.html#a429d750ca5b03823d6dea2ed3476b3ab">FindInternal</a> (std::string path, std::string <a class="el" href="generate__test__data__lte__spectrum__model_8m.html#ab74e6bf80237ddc4109968cedc58c151">name</a>)</td></tr>
<tr class="separator:a429d750ca5b03823d6dea2ed3476b3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad261506a54c7a4f7db29a856d8a9d6d2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1_names.html#ad261506a54c7a4f7db29a856d8a9d6d2">FindInternal</a> (<a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt; context, std::string <a class="el" href="generate__test__data__lte__spectrum__model_8m.html#ab74e6bf80237ddc4109968cedc58c151">name</a>)</td></tr>
<tr class="separator:ad261506a54c7a4f7db29a856d8a9d6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_a.html">A</a> directory of name and Ptr&lt;Object&gt; associations that allows us to give any <a class="el" href="namespacens3.html" title="The implementation of the public static-based API which calls into the private implementation through...">ns3</a> <a class="el" href="classns3_1_1_object.html" title="a base class which provides memory management and object aggregation ">Object</a> a name. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5075ee36f97059d897cf6430ce61e592"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Names::Add </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the association between the string "name" and the Ptr&lt;Object&gt; obj. </p>
<p>The name may begin either with "/Names" to explicitly call out the fact that the name provided is installed under the root of the name space, or it may begin with the name of the first object in the path. For example, <a class="el" href="classns3_1_1_names.html#a5075ee36f97059d897cf6430ce61e592" title="Add the association between the string &quot;name&quot; and the Ptr&lt;Object&gt; obj. ">Names::Add</a> ("/Names/client", obj) and <a class="el" href="classns3_1_1_names.html#a5075ee36f97059d897cf6430ce61e592" title="Add the association between the string &quot;name&quot; and the Ptr&lt;Object&gt; obj. ">Names::Add</a> ("client", obj) accomplish exactly the same thing. <a class="el" href="class_a.html">A</a> name at a given level in the name space path must be unique. In the case of the example above, it would be illegal to try and associate a different object with the same name: "client" at the same level ("/Names") in the path.</p>
<p>As well as specifying a name at the root of the "/Names" namespace, the name parameter can contain a path that fully qualifies the name to be added. For example, if you previously have named an object "client" in the root namespace as above, you could name an object "under" that name by making a call like <a class="el" href="classns3_1_1_names.html#a5075ee36f97059d897cf6430ce61e592" title="Add the association between the string &quot;name&quot; and the Ptr&lt;Object&gt; obj. ">Names::Add</a> ("/Names/client/eth0", obj). This will define the name "eth0" and make it reachable using the path specified. Note that <a class="el" href="classns3_1_1_names.html#a5075ee36f97059d897cf6430ce61e592" title="Add the association between the string &quot;name&quot; and the Ptr&lt;Object&gt; obj. ">Names::Add</a> ("client/eth0", obj) would accomplish exactly the same thing.</p>
<p>Duplicate names are not allowed at the same level in a path, however you may associate similar names with different paths. For example, if you define "/Names/Client", you may not define another "/Names/Client" just as you may not have two files with the same name in a classical filesystem. However, you may have "/Names/Client/eth0" and "/Names/Server/eth0" defined at the same time just as you might have different files of the same name under different directories.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the object you want to associate; which may be prepended with a path to that object. </td></tr>
    <tr><td class="paramname">object</td><td><a class="el" href="class_a.html">A</a> smart pointer to the object itself. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a251b61a3a52abf2c138c7bddcc0024"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Names::Add </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An intermediate form of <a class="el" href="classns3_1_1_names.html#a5075ee36f97059d897cf6430ce61e592" title="Add the association between the string &quot;name&quot; and the Ptr&lt;Object&gt; obj. ">Names::Add</a> allowing you to provide a path to the parent object (under which you want this name to be defined) in the form of a name path string. </p>
<p>In some cases, it is desirable to break up the path used to describe an item in the names namespace into a path and a name. This is analogous to a file system operation in which you provide a directory name and a file name.</p>
<p>For example, consider a situation where you have previously named an object "/Names/server". If you further want to create an association for between a Ptr&lt;Object&gt; object that you want to live "under" the server in the name space &ndash; perhaps "eth0" &ndash; you could do this in two ways, depending on which was more convenient: <a class="el" href="classns3_1_1_names.html#a5075ee36f97059d897cf6430ce61e592" title="Add the association between the string &quot;name&quot; and the Ptr&lt;Object&gt; obj. ">Names::Add</a> ("/Names/server/eth0", object) or, using the split path and name approach, <a class="el" href="classns3_1_1_names.html#a5075ee36f97059d897cf6430ce61e592" title="Add the association between the string &quot;name&quot; and the Ptr&lt;Object&gt; obj. ">Names::Add</a> ("/Names/server", "eth0", object).</p>
<p>Duplicate names are not allowed at the same level in a path, however you may associate similar names with different paths. For example, if you define "/Names/Client", you may not define another "/Names/Client" just as you may not have two files with the same name in a classical filesystem. However, you may have "/Names/Client/eth0" and "/Names/Server/eth0" defined at the same time just as you might have different files of the same name under different directories.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td><a class="el" href="class_a.html">A</a> path name describing a previously named object under which you want this new name to be defined. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the object you want to associate. </td></tr>
    <tr><td class="paramname">object</td><td><a class="el" href="class_a.html">A</a> smart pointer to the object itself.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classns3_1_1_names.html#a5075ee36f97059d897cf6430ce61e592" title="Add the association between the string &quot;name&quot; and the Ptr&lt;Object&gt; obj. ">Names::Add</a> (Ptr&lt;Object&gt; context, std::string <a class="el" href="generate__test__data__lte__spectrum__model_8m.html#ab74e6bf80237ddc4109968cedc58c151">name</a>, Ptr&lt;Object&gt; <a class="el" href="group__object.html">Object</a>); </dd></dl>

</div>
</div>
<a class="anchor" id="a93e958166cb8296bc0fa035668d83040"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Names::Add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_a.html">A</a> low-level form of <a class="el" href="classns3_1_1_names.html#a5075ee36f97059d897cf6430ce61e592" title="Add the association between the string &quot;name&quot; and the Ptr&lt;Object&gt; obj. ">Names::Add</a> allowing you to specify the path to the parent object (under which you want this name to be defined) in the form of a previously named object. </p>
<p>In some use cases, it is desirable to break up the path in the names name space into a path and a name. This is analogous to a file system operation in which you provide a directory name and a file name. Recall that the path string actually refers to a previously named object, "under" which you want to accomplish some naming action.</p>
<p>However, the path is sometimes not available, and you only have the object that is represented by the path in the names name space. To support this use-case in a reasonably high-performance way, the path string is can be replaced by the object pointer to which that path would refer. In the spirit of the <a class="el" href="namespacens3_1_1_config.html" title="Configuration of simulation parameters and tracing. ">Config</a> code where this use-case is most prominent, we refer to this object as the "context" for the names operation.</p>
<p>You can think of the context roughly as the inode number of a directory file in Unix. The inode number can be used to look up the directory file which contains the list of file names defined at that directory level. Similarly the context is used to look up an internal name service entry which contains the names defined for that context.</p>
<p>For example, consider a situation where you have previously named an object "/Names/server". If you further want to create an association for between a Ptr&lt;Object&gt; object that you want to live "under" the server in the name space &ndash; perhaps "eth0" &ndash; you could do this by providing a complete path to the new name: <a class="el" href="classns3_1_1_names.html#a5075ee36f97059d897cf6430ce61e592" title="Add the association between the string &quot;name&quot; and the Ptr&lt;Object&gt; obj. ">Names::Add</a> ("/Names/server/eth0", object). If, however, somewhere in your code you only had a pointer to the server, say <a class="el" href="classns3_1_1_ptr.html">Ptr&lt;Node&gt;</a> node, and not a handy path string, you could also accomplish this by <a class="el" href="classns3_1_1_names.html#a5075ee36f97059d897cf6430ce61e592" title="Add the association between the string &quot;name&quot; and the Ptr&lt;Object&gt; obj. ">Names::Add</a> (node, "eth0", object).</p>
<p>Duplicate names are not allowed at the same level in a path. In the case of this method, the context object gives the same information as a path string. You may associate similar names with different paths. For example, if you define"/Names/Client", you may not define another "/Names/Client" just as you may not have two files with the same name in a classical filesystem. However, you may have "/Names/Client/eth0" and "/Names/Server/eth0" defined at the same time just as you might have different files of the same name under different directories.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td><a class="el" href="class_a.html">A</a> smart pointer to an object that is used in place of the path under which you want this new name to be defined. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the object you want to associate. </td></tr>
    <tr><td class="paramname">object</td><td><a class="el" href="class_a.html">A</a> smart pointer to the object itself. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abda77642452c3e4a4ad8a76491dd2538"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Names::Clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the list of objects associated with names. </p>

</div>
</div>
<a class="anchor" id="a9d07094fb3d716d08733af05c1593555"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; T &gt; ns3::Names::Find </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a name path string, look to see if there's an object in the system with that associated to it. </p>
<p>Template definition of corresponding template declaration found in class <a class="el" href="classns3_1_1_names.html" title="A directory of name and Ptr&lt;Object&gt; associations that allows us to give any ns3 Object a name...">Names</a>.</p>
<p>If there is, do a GetObject on the resulting object to convert it to the requested typename and return it.</p>
<p>An object can be referred to in two ways. Either you can talk about it using its fully qualified path name, for example, "/Names/client/eth0" or you can refer to it by its name, in this case "eth0".</p>
<p>This method requires that the name path of the object be provided, e.g., "Names/client/eth0".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td><a class="el" href="class_a.html">A</a> string containing a name space path used to locate the object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a smart pointer to the named object converted to the requested type. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d9baba3c4fe189b9e2c493df9e70697"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; T &gt; ns3::Names::Find </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a path to an object and an object name, look through the names defined under the path to see if there's an object there with the given name. </p>
<p>Template definition of corresponding template declaration found in class <a class="el" href="classns3_1_1_names.html" title="A directory of name and Ptr&lt;Object&gt; associations that allows us to give any ns3 Object a name...">Names</a>.</p>
<p>In some cases, it is desirable to break up the path used to describe an item in the names namespace into a path and a name. This is analogous to a file system operation in which you provide a directory name and a file name.</p>
<p>For example, consider a situation where you have previously named an object "/Names/server/eth0". If you want to discover the object which you associated with this path, you could do this in two ways, depending on which was more convenient: <a class="el" href="classns3_1_1_names.html#a9d07094fb3d716d08733af05c1593555" title="Given a name path string, look to see if there&#39;s an object in the system with that associated to it...">Names::Find</a> ("/Names/server/eth0") or, using the split path and name approach, <a class="el" href="classns3_1_1_names.html#a9d07094fb3d716d08733af05c1593555" title="Given a name path string, look to see if there&#39;s an object in the system with that associated to it...">Names::Find</a> ("/Names/server", "eth0").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td><a class="el" href="class_a.html">A</a> path name describing a previously named object under which you want to look for the specified name. </td></tr>
    <tr><td class="paramname">name</td><td><a class="el" href="class_a.html">A</a> string containing a name to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a smart pointer to the named object converted to the requested type. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d2851cf2c04306722f838f37430d93f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; T &gt; ns3::Names::Find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a path to an object and an object name, look through the names defined under the path to see if there's an object there with the given name. </p>
<p>Template definition of corresponding template declaration found in class <a class="el" href="classns3_1_1_names.html" title="A directory of name and Ptr&lt;Object&gt; associations that allows us to give any ns3 Object a name...">Names</a>.</p>
<p>In some cases, it is desirable to break up the path used to describe an item in the names namespace into a path and a name. This is analogous to a file system operation in which you provide a directory name and a file name.</p>
<p>For example, consider a situation where you have previously named an object "/Names/server/eth0". If you want to discover the object which you associated with this path, you could do this in two ways, depending on which was more convenient: <a class="el" href="classns3_1_1_names.html#a9d07094fb3d716d08733af05c1593555" title="Given a name path string, look to see if there&#39;s an object in the system with that associated to it...">Names::Find</a> ("/Names/server/eth0") or, using the split path and name approach, <a class="el" href="classns3_1_1_names.html#a9d07094fb3d716d08733af05c1593555" title="Given a name path string, look to see if there&#39;s an object in the system with that associated to it...">Names::Find</a> ("/Names/server", "eth0").</p>
<p>However, the path is sometimes not available, and you only have the object that is represented by the path in the names name space. To support this use-case in a reasonably high-performance way, the path string is can be replaced by the object pointer to which that path would refer. In the spirit of the <a class="el" href="namespacens3_1_1_config.html" title="Configuration of simulation parameters and tracing. ">Config</a> code where this use-case is most prominent, we refer to this object as the "context" for the names operation.</p>
<p>You can think of the context roughly as the inode number of a directory file in Unix. The inode number can be used to look up the directory file which contains the list of file names defined at that directory level. Similarly the context is used to look up an internal name service entry which contains the names defined for that context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td><a class="el" href="class_a.html">A</a> smart pointer to an object that is used in place of the path under which you want this new name to be defined. </td></tr>
    <tr><td class="paramname">name</td><td><a class="el" href="class_a.html">A</a> string containing a name to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a smart pointer to the named object converted to the requested type. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d022d5483c79de459ce17e89d98d3f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt; ns3::Names::FindInternal </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a429d750ca5b03823d6dea2ed3476b3ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt; ns3::Names::FindInternal </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad261506a54c7a4f7db29a856d8a9d6d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt; ns3::Names::FindInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab9664faf23569aaae64a2d1f65265045"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ns3::Names::FindName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a pointer to an object, look to see if that object has a name associated with it and, if so, return the name of the object otherwise return an empty string. </p>
<p>An object can be referred to in two ways. Either you can talk about it using its fully qualified path name, for example, "/Names/client/eth0" or you can refer to it by its name, in this case "eth0".</p>
<p>This method returns the name of the object, e.g., "eth0".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td><a class="el" href="class_a.html">A</a> smart pointer to an object for which you want to find its name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string containing the name of the object if found, otherwise the empty string. </dd></dl>

</div>
</div>
<a class="anchor" id="af72bee5ceb8c2592ef37063311501498"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ns3::Names::FindPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a pointer to an object, look to see if that object has a name associated with it and return the fully qualified name path of the object otherwise return an empty string. </p>
<p>An object can be referred to in two ways. Either you can talk about it using its fully qualified path name, for example, "/Names/client/eth0" or you can refer to it by its name, in this case "eth0".</p>
<p>This method returns the name path of the object, e.g., "Names/client/eth0".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td><a class="el" href="class_a.html">A</a> smart pointer to an object for which you want to find its fullname.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string containing the name path of the object, otherwise the empty string. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ed4aa6358357bef3930cd19ba306373"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Names::Rename </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>oldpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>newname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rename a previously associated name. </p>
<p>The name may begin either with "/Names" to explicitly call out the fact that the name provided is installed under the root of the name space, or it may begin with the name of the first object in the path. For example, <a class="el" href="classns3_1_1_names.html#a0ed4aa6358357bef3930cd19ba306373" title="Rename a previously associated name. ">Names::Rename</a> ("/Names/client", "server") and <a class="el" href="classns3_1_1_names.html#a0ed4aa6358357bef3930cd19ba306373" title="Rename a previously associated name. ">Names::Rename</a> ("client", "server") accomplish exactly the same thing. <a class="el" href="classns3_1_1_names.html" title="A directory of name and Ptr&lt;Object&gt; associations that allows us to give any ns3 Object a name...">Names</a> at a given level in the name space path must be unique. In the case of the example above, it would be illegal to try and rename a different object to the same name: "server" at the same level ("/Names") in the path.</p>
<p>As well as specifying a name at the root of the "/Names" namespace, the name parameter can contain a path that fully qualifies the name to be changed. For example, if you previously have (re)named an object "server" in the root namespace as above, you could then rename an object "under" that name by making a call like <a class="el" href="classns3_1_1_names.html#a0ed4aa6358357bef3930cd19ba306373" title="Rename a previously associated name. ">Names::Rename</a> ("/Names/server/csma", "eth0"). This will rename the object previously associated with "/Names/server/csma" to "eth0" and make leave it reachable using the path "/Names/server/eth0". Note that <a class="el" href="classns3_1_1_names.html#a0ed4aa6358357bef3930cd19ba306373" title="Rename a previously associated name. ">Names::Rename</a> ("server/csma", "eth0") would accomplish exactly the same thing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldpath</td><td>The current path name to the object you want to change. </td></tr>
    <tr><td class="paramname">newname</td><td>The new name of the object you want to change.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classns3_1_1_names.html#a5075ee36f97059d897cf6430ce61e592" title="Add the association between the string &quot;name&quot; and the Ptr&lt;Object&gt; obj. ">Names::Add</a> (std::string <a class="el" href="generate__test__data__lte__spectrum__model_8m.html#ab74e6bf80237ddc4109968cedc58c151">name</a>, Ptr&lt;Object&gt; obj) </dd></dl>

</div>
</div>
<a class="anchor" id="a8e7b8a3e5e9423ef8c61d6ad216ca81c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Names::Rename </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>oldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>newname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An intermediate form of <a class="el" href="classns3_1_1_names.html#a0ed4aa6358357bef3930cd19ba306373" title="Rename a previously associated name. ">Names::Rename</a> allowing you to provide a path to the parent object (under which you want this name to be changed) in the form of a name path string. </p>
<p>In some cases, it is desirable to break up the path used to describe an item in the names namespace into a path and a name. This is analogous to a file system operation in which you provide a directory name and a file name.</p>
<p>For example, consider a situation where you have previously named an object "/Names/server/csma". If you want to change the name "csma" to "eth0", you could do this in two ways, depending on which was more convenient: <a class="el" href="classns3_1_1_names.html#a0ed4aa6358357bef3930cd19ba306373" title="Rename a previously associated name. ">Names::Rename</a> ("/Names/server/csma", "eth0") or, using the split path and name approach, <a class="el" href="classns3_1_1_names.html#a0ed4aa6358357bef3930cd19ba306373" title="Rename a previously associated name. ">Names::Rename</a> ("/Names/server", "csma", "eth0").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td><a class="el" href="class_a.html">A</a> path name describing a previously named object under which you want this name change to occur (cf. directory). </td></tr>
    <tr><td class="paramname">oldname</td><td>The currently defined name of the object. </td></tr>
    <tr><td class="paramname">newname</td><td>The new name you want the object to have. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad6474f8c16e99575397c5c243a3f9aa4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::Names::Rename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classns3_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classns3_1_1_object.html">Object</a> &gt;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>oldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>newname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_a.html">A</a> low-level form of <a class="el" href="classns3_1_1_names.html#a0ed4aa6358357bef3930cd19ba306373" title="Rename a previously associated name. ">Names::Rename</a> allowing you to specify the path to the parent object (under which you want this name to be changed) in the form of a previously named object. </p>
<p>In some use cases, it is desirable to break up the path in the names name space into a path and a name. This is analogous to a file system operation in which you provide a directory name and a file name. Recall that the path string actually refers to a previously named object, "under" which you want to accomplish some naming action.</p>
<p>However, the path is sometimes not available, and you only have the object that is represented by the path in the names name space. To support this use-case in a reasonably high-performance way, the path string is can be replaced by the object pointer to which that path would refer. In the spirit of the <a class="el" href="namespacens3_1_1_config.html" title="Configuration of simulation parameters and tracing. ">Config</a> code where this use-case is most prominent, we refer to this object as the "context" for the names operation.</p>
<p>You can think of the context roughly as the inode number of a directory file in Unix. The inode number can be used to look up the directory file which contains the list of file names defined at that directory level. Similarly the context is used to look up an internal name service entry which contains the names defined for that context.</p>
<p>For example, consider a situation where you have previously named an object "/Names/server/csma". If you later decide to rename the csma object to say "eth0" &ndash; you could do this by providing a complete path as in <a class="el" href="classns3_1_1_names.html#a0ed4aa6358357bef3930cd19ba306373" title="Rename a previously associated name. ">Names::Rename</a> ("/Names/server/csma", "eth0"). If, however, somewhere in your code you only had a pointer to the server, and not a handy path string, say <a class="el" href="classns3_1_1_ptr.html">Ptr&lt;Node&gt;</a> node, you could also accomplish this by <a class="el" href="classns3_1_1_names.html#a0ed4aa6358357bef3930cd19ba306373" title="Rename a previously associated name. ">Names::Rename</a> (node, "csma", "eth0").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td><a class="el" href="class_a.html">A</a> smart pointer to an object that is used in place of the path under which you want this new name to be defined. </td></tr>
    <tr><td class="paramname">oldname</td><td>The current shortname of the object you want to change. </td></tr>
    <tr><td class="paramname">newname</td><td>The new shortname of the object you want to change. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacens3.html">ns3</a></li><li class="navelem"><a class="el" href="classns3_1_1_names.html">Names</a></li>
    <li class="footer">Generated on Thu May 16 2024 11:27:05 for My Project by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
